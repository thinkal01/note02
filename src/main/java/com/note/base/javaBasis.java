package com.note.base;

import org.junit.Test;

public class javaBasis {
    @Test
    public void test() {
        System.out.println(0b100); //二进制
        System.out.println(0100); //八进制
        System.out.println(0x100); //十六进制
    }

    @Test
    public void test05() {
        // byte b = 25;
        byte b = 99;
        String s = Integer.toBinaryString(b); // 11001,25
        // 取高四位至低四位
        int high = b >>> 4 & 0b00001111;
        // 取低四位
        int low = b & 0b00001111;
        String sHigh = Integer.toBinaryString(high);
        String sLow = Integer.toBinaryString(low);
    }

    @Test
    public void test02() {
        //定义了三个byte类型的变量，b1，b2，b3
        //b1的值是3，b2的值是4，b没有值
        byte b1 = 3, b2 = 4, b;

        // b = b1 + b2; //这个是类型提升，变量相加，首先看类型问题，最终把结果赋值也会考虑类型问题
        // 常量，先把结果计算出来，然后看是否在byte的范围内，如果在就不报错。
        b = 3 + 4;

        // byte的范围：-128 ~ 127
        b2 = (byte) 128; //-128
        byte b3 = (byte) 129; //-127
        byte b4 = (byte) 130; //-126
    }

    @Test
    public void test03() {
        //byte的范围是：-128到127
        //可以使用强制类型转换
        byte b = (byte) 130;

/*	分析过程：
		我们要想知道结果是什么，就应该知道是如何进行计算的。
		而我们又知道计算机中数据的运算都是补码进行的。
		而要得到补码，首先要计算出数据的二进制。

		A:获取130这个数据的二进制。
			00000000 00000000 00000000 10000010
			这是130的原码，也是反码，还是补码。
		B:做截取操作，截成byte类型的了。
			10000010
			这个结果是补码。
		C:已知补码求原码。
					符号位		数值位
			补码：	1			0000010

			反码：	1			0000001

			原码：	1			1111110
*/
    }

    /*
        <<:左移	左边最高位丢弃，右边补齐0
        >>:右移	最高位是0，左边补齐0；最高为是1，左边补齐1
        >>>:无符号右移 无论最高位是0还是1，左边补齐0

        面试题：
            请用最有效率的方式写出计算2乘以8的结果
                2 * 8
                2 << 3
    */
    @Test
    public void test04() {
        //<< 把<<左边的数据乘以2的移动次幂
        System.out.println(3 << 2); //3*2^2 = 3*4 = 12;

        //>> 把>>左边的数据除以2的移动次幂
        System.out.println(24 >> 2); //24 / 2^2 = 24 / 4 = 6
        System.out.println(24 >>> 2);

        System.out.println(-24 >> 2);
        System.out.println(-24 >>> 2);
/*  >>的移动：
        计算出24的二进制：11000
        原码：10000000 00000000 00000000 00011000
        反码：11111111 11111111 11111111 11100111
        补码：11111111 11111111 11111111 11101000

        11111111 11111111 11111111 11101000
        1111111111 11111111 11111111 111010 (00) 补码

        补码：1111111111 11111111 11111111 111010
        反码：1111111111 11111111 11111111 111001
        原码：1000000000 00000000 00000000 000110

        结果：-6

    >>> 的移动：
        计算出24的二进制：11000
        原码：10000000 00000000 00000000 00011000
        反码：11111111 11111111 11111111 11100111
        补码：11111111 11111111 11111111 11101000

        11111111 11111111 11111111 11101000
        0011111111 11111111 11111111 111010 (00)
*/
    }


}
